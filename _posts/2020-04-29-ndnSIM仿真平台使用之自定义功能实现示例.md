---
title: ndnSIM仿真平台使用之自定义功能实现示例
tags:	ndnSIM
key: 20200429
---

本文将提供若干个ndnSIM源码修改示例，实现不同的自定义功能，以进一步介绍ndnSIM仿真平台的使用。

<!--more-->

版本信息如下：

操作系统：Ubuntu 16.04 <br>ndnSIM：ndnSIM-2.1<br>
ns-3-dev：ns-3.23-dev-ndnSIM-2.1<br>

## 添加CS表的删除记录操作Erase()

如前文所述，ndnSIM提供了两种Content Store的实现，其中最常用到的是旧版实现 `ns3::Ptr<ns3::ndn::ContentStore> m_csFromNdnSim`，在forwarder.cpp中存储数据包时的代码为：

```c++
shared_ptr<Data> dataCopyWithoutPacket = make_shared<Data>( data );
dataCopyWithoutPacket->removeTag<ns3::ndn::Ns3PacketTag>();
m_csFromNdnSim->Add( dataCopyWithoutPacket );
```

而ndnSIM并未直接提供删除数据包的操作`m_csFromNdnSim->Erase( dataCopyWithoutPacket )`，如果需要用到删除功能，则需修改源码。接下来我们将在介绍如何添加删除功能的同时，介绍ndnSIM中ContentStore的实现。

### ContentStore类

> 旧版路径（本文使用旧版）：ndnSIM/model/cs/ndn-content-store.hpp，ndnSIM/model/cs/ndn-content-store.cpp
>
> 旧版缓存替换策略路径：ndnSIM/utils/trie
>
> 新版路径：ndnSIM/NFD/daemon/table/cs.hpp，ndnSIM/NFD/daemon/table/cs.cpp
>
> 新版缓存替换策略路径：ndnSIM/NFD/daemon/table

ContentStore类是CS表的基类，在头文件ndn-content-store.hpp里定义了若干操作如下：

```c++
class ContentStore : public Object {
public:
	...
  virtual shared_ptr<Data>
  Lookup(shared_ptr<const Interest> interest) = 0; // 查询是否有兴趣包对应的数据包

  virtual bool
  Add(shared_ptr<const Data> data) = 0; // 存储数据包（存储新记录）

  virtual void
  Print(std::ostream& os) const = 0; // 打印记录

  virtual uint32_t
  GetSize() const = 0; // 获取当前CS表大小

  virtual Ptr<cs::Entry> 
  Begin() = 0;	// 获取当前CS表的第一个记录

  virtual Ptr<cs::Entry>
  End() = 0;	// 获取当前CS表的最后一个记录

  virtual Ptr<cs::Entry> Next(Ptr<cs::Entry>) = 0;	// 获取当前CS表某记录的吓一条记录

  static inline Ptr<ContentStore>
  GetContentStore(Ptr<Object> node); // 获取当前CS表
	...
};
```

可见原生ContentStore类并未提供删除记录功能，因此我们首先在ndn-content-store.hpp中定义删除记录方法`Erase()`，此处可以依据兴趣包删除记录，也可以依据数据包删除记录，前者用于forwarder.cpp中兴趣包处理相关方法中（如`onIncomingInterest()`），后者用于数据包处理相关方法中（如`onIncomingData()`），我们以后者为例：

```c++
class ContentStore : public Object {
public:
	...
  virtual void
  Erase(shared_ptr<const Data> data) = 0;
	...
};
```

此外，这里使用到了纯虚函数的概念，即虚函数后加上“=0”。虚函数用于使用基类指针调用子类的函数，其既可以在基类中实现，也可以在子类中实现。纯虚函数用于定义接口，**在基类中并不实现它，而在子类中必须实现它**。其他关于虚函数与纯虚函数的详细用法请自行学习，网络上有大量的相关资料。

### ContentStoreImpl类

> 路径：ndnSIM/model/cs/content-store-impl.hpp，ndnSIM/model/cs/content-store-impl.cpp

ContentStoreImpl类是CS表的基础实现类，且是一个模板类（这里建议先对C++的模板进行了解）,它有两个父类，一个是上述的ContentStore类，一个是trie_with_policy类（路径：ndnSIM/utils/trie/trie-with-policy.hpp），后者与各种缓存替换策略有关，如果需要实现自定义的缓存替换策略，trie_with_policy类需要详细学习，这一部分暂时不在本文的介绍范围之内：

```c++
template<class Policy>
class ContentStoreImpl
  : public ContentStore, // 父类1
    protected ndnSIM::
      trie_with_policy<Name,
      ndnSIM::smart_pointer_payload_traits<EntryImpl<ContentStoreImpl<Policy>>,Entry>,
      Policy> // 父类2
{
public:
  typedef ndnSIM::
    trie_with_policy<Name, ndnSIM::smart_pointer_payload_traits<EntryImpl<ContentStoreImpl<Policy>>,
                                                                Entry>,
                     Policy> super; // super指代父类2
  ...
  virtual inline shared_ptr<Data>
  Lookup(shared_ptr<const Interest> interest);

  virtual inline bool
  Add(shared_ptr<const Data> data);

  virtual inline void
  Print(std::ostream& os) const;

  virtual uint32_t
  GetSize() const;

  virtual Ptr<Entry>
  Begin();

  virtual Ptr<Entry>
  End();

  virtual Ptr<Entry> Next(Ptr<Entry>);

  const typename super::policy_container&
  GetPolicy() const
  {
    return super::getPolicy();
  }

  typename super::policy_container&
  GetPolicy()
  {
    return super::getPolicy();
  }
  ...
};
```

可以看出该类体中首先分别定义了两个父类中的方法，其中并没有删除记录的方法，因此我们在此处再次定义`Erase()`方法：

```c++
template<class Policy>
class ContentStoreImpl
  : public ContentStore, // 父类1
    protected ndnSIM::
      trie_with_policy<Name,
      ndnSIM::smart_pointer_payload_traits<EntryImpl<ContentStoreImpl<Policy>>,Entry>,
      Policy> // 父类2
{
public:
  ...
  virtual inline void
  Erase(shared_ptr<const Data> data);
  ...
};
```

然后在类体外实现`Erase()`方法：

```c++
template<class Policy>
void
ContentStoreImpl<Policy>::Erase(shared_ptr<const Data> data)
{
  NS_LOG_FUNCTION(this << " ERASE " << data->getName());
  super::erase(data->getName());
}
```

此处需要解释为什么用`super::erase(data->getName());`，这是因为ContentStoreImpl类的父类1并未实现该方法，而父类2中有实现，因此我们在这里直接调用父类2中的`erase()`方法即可。	

### 使用

在forwarder.cpp中需要删除操作的地方加入以下代码即可：

```c++
m_csFromNdnSim->Erase( data );
```

比如我们在`onIncomingData()`中作如下修改，先添加记录再删除记录然后再添加记录，此代码并无实际意义，仅用作功能展示：

```c++
void
Forwarder::onIncomingData(Face& inFace, const Data& data)
{
  ...
  shared_ptr<Data> dataCopyWithoutPacket = make_shared<Data>(data);
  dataCopyWithoutPacket->removeTag<ns3::ndn::Ns3PacketTag>();

  // CS insert
  if (m_csFromNdnSim == nullptr)
    m_cs.insert(*dataCopyWithoutPacket);
  else{
    m_csFromNdnSim->Add(dataCopyWithoutPacket);
    m_csFromNdnSim->Erase(dataCopyWithoutPacket);
    std::cout<<" erase:"<< dataCopyWithoutPacket->getName() <<std::endl; 
    m_csFromNdnSim->Add(dataCopyWithoutPacket);
  }
  ...
}
```

然后我们运行ndn-simple.cpp，发现报错：

![image](https://github.com/kanyuanzhi/kanyuanzhi.github.io/raw/master/assets/myimages/20200429/1.jpg)

可以看出问题出在content-store-nocache.hpp与content-store-nocache.cpp中，且与纯虚函数有关。我们打开content-store-nocache.hpp，发现其父类也是ContentStore类：

```c++
class Nocache : public ContentStore {
  ...
}
```

而我们在ContentStore类中新定义的纯虚函数`Erase()`必须在子类中实现，以上我们仅在其一个子类ContentStoreImpl类中实现，并未在子类Nocache类中实现。因此我们接下来只需要在Nocache类中实现该纯虚函数即可。

在content-store-nocache.hpp中添加：

```c++
class Nocache : public ContentStore {
public:
  ...
  virtual bool
  Add(shared_ptr<const Data> data);

  virtual void
  Erase(shared_ptr<const Data> data);
  ...
};
```

在content-store-nocache.cpp中添加：

```c++
...
void
Nocache::Erase(shared_ptr<const Data> data)
{
}
...
```

然后运行ndn-simple.cpp，发现可以正常运行，同一个内容名称连续打印四次是因为在该ndn-simple.cpp中我们设置了四个串联节点。

![image](https://github.com/kanyuanzhi/kanyuanzhi.github.io/raw/master/assets/myimages/20200429/2.jpg)

## 路由节点创建并发出兴趣包

