---
title: ndnSIM仿真平台使用之仿真数据获取与处理
tags:	ndnSIM
key: 20200327
---

本文首先介绍如何通过平台内建输出程序与打印运行日志两种方式获取仿真数据，然后介绍如何使用Python处理这些数据。

<!--more-->

版本信息如下：

操作系统：Ubuntu 16.04 <br>ndnSIM：ndnSIM-2.1<br>
ns-3-dev：ns-3.23-dev-ndnSIM-2.1<br>

## 数据获取

ndnSIM仿真实验中，常用的数据为每个节点的缓存命中率和吞吐量（包括packets/s与kilobytes/s）等，如果不对ndnSIM的转发与缓存代码做修改，这两种数据均可使用内建的输出程序获得，但是当为了实现自定义的转发与缓存策略需要大量修改相关源码时，内建的输出程序输出的数据会不准确。因此，最为稳妥的方式是打印运行日志以获取所需数据。

### 平台内建输出程序

此部分主要参考官网文档，[NFD’s Content Store](https://ndnsim.net/2.1/cs.html)和[Obtaining metrics](https://ndnsim.net/2.1/metric.html)。

#### 1. 缓存命中率

ndnSIM2.1中支持两种版本的Content Store实现，新版本的CS中只有FIFO缓存替换策略，旧版本的CS中缓存替换策略更加丰富（此处官网有更详细的介绍<https://ndnsim.net/2.1/cs.html>），且只有使用旧版本的实现才可使用平台内建的命中数与丢失数统计程序。如果研究目的不涉及到新的缓存策略，推荐使用旧版本的CS。以ndn-simple.cpp（在原示例中增加一个节点）文件为例，使用旧版CS且缓存替换策略为LRU，即：

```c++
// Install NDN stack on all nodes
ndn::StackHelper ndnHelper;
ndnHelper.SetDefaultRoutes(true);
ndnHelper.SetOldContentStore("ns3::ndn::cs::Lru", "MaxSize", "100");
ndnHelper.InstallAll();
```

然后在`Simulator::Run()`前添加缓存命中信息输出代码：

```c++
ndn::CsTracer::InstallAll("cs-trace.txt", Seconds(1.0));
Simulator::Run();
Simulator::Destroy();
```

其中`Seconds(1.0)`表示1秒统计1次。然后运行ndn-simple.cpp，在ns-3的主目录下，可以发现程序输出cs-trace.txt文件，内容为：

![image](https://github.com/kanyuanzhi/kanyuanzhi.github.io/raw/master/assets/myimages/20200327/1.jpg)

可以看出程序每隔1秒输出一次每个节点的命中包数与丢失包数，稍加计算即可得到单个缓存节点的命中率与全网平均命中率。

#### 2. 节点吞吐量

使用`ndn::L3RateTracer`可以输出每个节点的流量信息，其中常用的为进/出兴趣包/数据包数量，在`Simulator::Run()`前添加如下代码：

```c++
ndn::L3RateTracer::InstallAll("rate-trace.txt", Seconds(1.0));
Simulator::Run();
```

然后运行ndn-simple.cpp，在ns-3的主目录下，可以发现程序输出文件rate-trace.txt，内容为：

|                            节点0                             |                            节点1                             |
| :----------------------------------------------------------: | :----------------------------------------------------------: |
| ![image](https://github.com/kanyuanzhi/kanyuanzhi.github.io/raw/master/assets/myimages/20200327/2.jpg) | ![image](https://github.com/kanyuanzhi/kanyuanzhi.github.io/raw/master/assets/myimages/20200327/3.jpg) |

|                            节点2                             |                            节点3                             |
| :----------------------------------------------------------: | :----------------------------------------------------------: |
| ![image](https://github.com/kanyuanzhi/kanyuanzhi.github.io/raw/master/assets/myimages/20200327/4.jpg) | ![image](https://github.com/kanyuanzhi/kanyuanzhi.github.io/raw/master/assets/myimages/20200327/5.jpg) |

由上可以清楚看到每个节点的InInterests、OutInterests、InData和OutData等信息，统计指标包括数量与字节。这里要额外说明第四列FaceDescr的选择，注意到每个节点包括四种FaceDescr：internal、netDeviceFace、ndnFace和appFace。我们需要用到的是netDeviceFace和appFace。

为了介绍这两种FaceDescr的区别，我们再次说明实验中用到的ndn-simple.cpp的拓扑结构：节点0、1、2、3串联，节点0上安装用户（Consumer），节点3上安装服务器（Provider）。

在上图中，节点1和节点2的netDeviceFace有两个端口号，而节点0和节点3的netDeviceFace只有一个端口号，因此netDeviceFace表示该节点与其他路由节点相连的端口。节点1和节点2没有appFace，而节点0和节点3分别有一个appFace，因此appFace表示该节点与用户或服务器相连的端口。

因此在这个示例中，统计服务器的负载时使用的是节点3的appFace端口的OutInterests和InData的信息。

### 打印运行日志

ndnSIM最常用的运行示例的方式是在终端里直接输入：

```
./waf configure --enable-examples
./waf --run ndn-simple
```

此时终端里仅输出开始与结束的信息（或者以`cout`方式打印出来的信息）。

![image](https://github.com/kanyuanzhi/kanyuanzhi.github.io/raw/master/assets/myimages/20200327/6.jpg)

此外，ndnSIM还支持以日志模式运行示例，可以打印出代码中`NS_LOG*`内的信息。在终端里输入：

```
NS_LOG=ndn.Consumer:ndn.Producer:nfd.Forwarder ./waf --run ndn-simple
```

此时终端里输出所选择`NS_LOG`的信息，以上命令中为`ndn.Producer`和`ndn.Consumer`（多选时用“：”隔开），即生产者类的方法里`NS_LOG_INFO(*)`中的内容、用户类的方法里`NS_LOG_INFO(*)`的内容和转发类的方法里`NFD_LOG_DEBUG(*)`中的内容，例如：

|              ndn.Consumer，在ndn-comsumer.cpp中              |
| :----------------------------------------------------------: |
| ![image](https://github.com/kanyuanzhi/kanyuanzhi.github.io/raw/master/assets/myimages/20200327/7.jpg) |
|                         对应终端显示                         |
| ![image](https://github.com/kanyuanzhi/kanyuanzhi.github.io/raw/master/assets/myimages/20200327/7_2.jpg) |

|              ndn.Producer，在ndn-producer.cpp中              |
| :----------------------------------------------------------: |
| ![image](https://github.com/kanyuanzhi/kanyuanzhi.github.io/raw/master/assets/myimages/20200327/8.jpg) |
|                         对应终端显示                         |
| ![image](https://github.com/kanyuanzhi/kanyuanzhi.github.io/raw/master/assets/myimages/20200327/8_2.jpg) |

|               ndn.Forwarder，在forwarder.cpp中               |
| :----------------------------------------------------------: |
| ![image](https://github.com/kanyuanzhi/kanyuanzhi.github.io/raw/master/assets/myimages/20200327/9.jpg) |
|                         对应终端显示                         |
| ![image](https://github.com/kanyuanzhi/kanyuanzhi.github.io/raw/master/assets/myimages/20200327/9_2.jpg) |

`NS_LOG=*`能够选择的参数有很多，可以在终端里输入一个错误的参数以查看所有有效参数列表，如：

![image](https://github.com/kanyuanzhi/kanyuanzhi.github.io/raw/master/assets/myimages/20200327/10.jpg)

这里参数的名称实际上可以在对应文件的开头找到，比如在ndn-producer.cpp中，有如下定义：

![image](https://github.com/kanyuanzhi/kanyuanzhi.github.io/raw/master/assets/myimages/20200327/11.jpg)

所以如果自定义一个producer，比如ndn.ProducerNew，需要在对应ndn-producer-new.cpp文件中指定名称，即`NS_LOG_COMPONENT_DEFINE("ndn.ndn.ProducerNew")`。

## 数据处理























